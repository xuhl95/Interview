# 问题与简答

## 设计模式篇

### 单例模式

#### 单例模式的概念

单例模式是指整个应用中某个类只有一个对象实例的设计模式。具体来说，作为对象的创建方式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统全局的提供这个实例。它不会创建实例副本，而是会向单例类内部存储的实例返回一个引用。

#### 单例模式的特点

>单例模式的主要特点是“三私一公”：

- 需要一个保存类的唯一实例的私有静态成员变量
- 构造函数必须声明为私有的，防止外部程序new一个对象从而失去单例的意义
- 克隆函数必须声明为私有的，防止对象被克隆
- 必须提供一个访问这个实例的公共静态方法(通常命名为getInstance)，从而返回唯一实例的一个引用。

#### 使用单例模式的原因及场景

> 在PHP的大多数应用中都会存在大量的数据库操作，如果不用单例模式，那每次都要new操作，但是每次new都会消耗大量的系统资源和内存资源，而且每次打开和关闭数据库都是对数据库的一种极大考验和浪费。所以单例模式经常用在数据库操作类中。
同样，如果系统中需要有一个类来全局控制某些配置信息，那使用单例模式可以很方便的实现。

#####以实例化一个Mysql数据库类为例：
要实现一个类只实例化一次，就必须堵住其他实例化的入口。

1、实例化类时，会自动调用类的构造方法，因为将构造方法设置为private属性，限制为只能在类内部实例化

```
//私有构造方法，防止在类的外部实例化
private function __construct() {
    # code...
}
```

2、定义一个静态方法，在类内部实例化对象。实例化前先判断该类是否已被实例化了，若已被实例化，就返回该实例化对象；若没被实例化，便实例化一个对象并将该对象保存在类的静态属性中

```
//私有静态属性，存放该类的实例
private static $instance = null;
 
//公共的静态方法，实例化该类本身，只实例化一次
public static function getInstance() {
 
    if (!self::$instance instanceof self) {
 
       self::$instance = new self;
    }
 
    return self::$instance;
 
}
```

3、禁止克隆，对象之间进行克隆可生成不同的对象。而克隆时会自动调用类的__conle方法，因此将克隆方法设置为private属性

```
//私有克隆方法，防止克隆
private function __clone(){
    # code...
}
```

综上，三私一公（三个私有属性和一个公共方法）单例模式的代码如下：

```
class DB
{
    private static $instance = null; //私有静态属性，存放该类的实例
 
    private function __construct() //私有构造方法，防止在类的外部实例化
    {
        # code...
    }
 
 
    private function __clone() //私有克隆方法，防止克隆
    {
        # code
    }
 
 
    public static function getInstance() //公共的静态方法，实例化该类本身，只实例化一次
    {
        if (!self::$instance instanceof self) {
            self::$instance = new self;
        }
        return self::$instance;
    }
}

```
