# 算法

## 目录


- 排序算法
  - [冒泡排序](#冒泡排序)
  - [选择排序](#选择排序)
  - 插入排序
  - 快速排序
  - 堆排序
  - 归并排序
  
- 查找算法
  - 二分查找
  - hash
  - KPM
  
- 其它
  - 布隆过滤器
  - 贪心算法
  - 回溯算法
  - 动态规划
  - 最小生成树
  - 最短路径
  - 推荐算法
  - 深度优先、广度优先
    
    
### 排序算法

#### 冒泡排序
- 原理
    
   > 比较相邻的元素。如果第一个比第二个大，就交换他们两个。

   > 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。

  > 针对所有的元素重复以上的步骤，除了最后一个。

  > 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

- 代码实现
```
<?php

function bubbleSort(array $arr) {
    // 第一层可以理解为从数组中键为0开始循环到最后一个
    for ($i = 0; $i < count($arr); $i++) {
        for ($j = $i + 1; $j < count($arr); $j++) {
            // 比较数组中两个相邻值的大小
            if ($arr[$i] > $arr[$j]) {
                $tmp     = $arr[$j]; // 临时变量从放$i的值
                $arr[$j] = $arr[$i]; // 第一次更换位置
                $arr[$i] = $tmp; // 完成位置互换
            }
        }
    }

    return $arr;
}

print_r(bubbleSort([23, 15, 43, 25, 54, 2, 6, 82, 11, 5, 21, 32, 65]));
```

### 选择排序

- 原理
   > 选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 n 个元素的表进行排序总共进行至多 n -1 次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种

- 代码实现
```
// 选择排序
function selectSort($arr) {
    $count = count($arr);

    if ($count < 2) {
        return $arr;
    }

    for ($i = 0; $i < $count - 1; $i++) {
        // 当前值的位置
        $key = $i;
        for ($k = $i + 1; $k < $count; $k++) {
            // 相邻值进行比较，条件成立替换当前值
            // 倒序 $arr[$key] < $arr[$k]
            if ($arr[$key] > $arr[$k]) {
                $key = $k;
            }
        }

        if ($key != $i) {
            // 交换位置
            $temp      = $arr[$key];
            $arr[$key] = $arr[$i];
            $arr[$i]   = $temp;
        }
    }

    return $arr;
}
// 选择排序
print_r(selectSort([8, 2, 5, 88, 1, 4, 90]));
```

### 二分查找

原理

二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。

代码示例
```
function binsearch($x,$a){
    $c=count($a);
    $lower=0;
    $high=$c-1;
    while($lower<=$high){
        $middle=intval(($lower+$high)/2);
        if($a[$middle]>$x){
            $high=$middle-1;
        } elseif($a[$middle]<$x){
            $lower=$middle+1;
        } else{
            return $middle;
        }
    }
    return -1;
}
```

