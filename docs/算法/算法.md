# 算法

## 目录


- 排序算法
  - [冒泡排序](#冒泡排序)
  - [选择排序](#选择排序)
  - 插入排序
  - 快速排序
  - 堆排序
  - 归并排序
  
- 查找算法
  - 二分查找
  - hash
  - KPM
  
- 其它
  - 布隆过滤器
  - 贪心算法
  - 回溯算法
  - 动态规划
  - 最小生成树
  - 最短路径
  - 推荐算法
  - 深度优先、广度优先
    
    
### 排序算法

#### 冒泡排序
- 原理
    
   > 比较相邻的元素。如果第一个比第二个大，就交换他们两个。

   > 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。

  > 针对所有的元素重复以上的步骤，除了最后一个。

  > 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

- 代码实现
```
<?php

/**
 * 排序
 */
class sort {

    /**
     * 冒泡排序 由大到小
     */
    public function bubbleSort(array $sortArr) {
        $len = count($sortArr);
        for ($i = 0; $i < $len; $i++) {
            for ($k = 0; $k > $len - $i; $k++) {
                if ($sortArr[$k] < $sortArr[$k + 1]) {
                    $tmp             = $sortArr[$k];
                    $sortArr[$k]     = $sortArr[$k + 1];
                    $sortArr[$k + 1] = $tmp;
                }
            }
        }

        return $sortArr;
    }
}
// 冒泡排序
$obj = new sort();
var_dump($obj->bubbleSort([8, 2, 5, 88, 1, 4, 90]));
```

### 选择排序

- 原理
   > 选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 n 个元素的表进行排序总共进行至多 n -1 次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种

- 代码实现
```
// 选择排序
function selectSort($arr) {
    $count = count($arr);

    if ($count < 2) {
        return $arr;
    }

    for ($i = 0; $i < $count - 1; $i++) {
        // 当前值的位置
        $key = $i;
        for ($k = $i + 1; $k < $count; $k++) {
            // 相邻值进行比较，条件成立替换当前值
            // 倒序 $arr[$key] < $arr[$k]
            if ($arr[$key] > $arr[$k]) {
                $key = $k;
            }
        }

        if ($key != $i) {
            // 交换位置
            $temp      = $arr[$key];
            $arr[$key] = $arr[$i];
            $arr[$i]   = $temp;
        }
    }

    return $arr;
}
// 选择排序
print_r(selectSort([8, 2, 5, 88, 1, 4, 90]));
```

### 查找算法
